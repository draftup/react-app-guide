# Архитектура

Архитектура приложения - набор характеристик, отражающих способность проекта к долгосрочному развитию и поддержке.

## Ментальная модель

Ментальная модель приложения - абстракция, отражающая особенности взаимодействие ключевых комопнентов системы. Между качеством ментальной модели и качеством архитектуры приложения существует положительная связь.

В рамкак этого путеводителя используется универсальная ментальная модель, в основе которой лежит разделение компонентов системы на хранилища состояний и сервисы.

- Хранилище состояния - компонент системы, ответственный за хранение актуального состояния прикладной области и его имзенение в ответ на события из слоя сервисов. 

- Сервис - компонент системы, ответственный за передачу актуального состояния внешними источниками данных (удаленным ресурсам, интерфейсам среды выполнения, пользователям) и передачу их ответа обратно в хранилище состояния в нормализованном виде. Сервисы изолированы друг от друга и могут взаимодействовать лишь опосредованно через хранилище состояния.

### Одно хранилище состояния - множество сервисов

```
                Logger Service
       state    Audio Service
       ====>    GUI service
STORE           CLUI Service
       <====    Repository Service
       event    Geolocation Service
                I18n Service
```

При такой архитектуре в приложении используется одно единственное хранилище состояния и множество сервисов. Это позволяет гибко реагировать на изменение зон ответственности, когда конкретной сервис начинает требовать для своей работы информацию, которую раньше он не использовал. В этом случае проблема решается быстро, так как любой сервис имеет доступ ко всему состоянию целиком изначально. С другой стороны такая архитектура может потребовать дополнительных усилий по оптимизации в случае, если изменился участок состояния в котором сервис не заинтересован.

## Слои приложения

Компоненты системы, ответственные за выполнение четко выраженной задачи, представляют собой отдельный **логический слой** этой системы. Для повышения надежности приложения характерно стремление к изоляции слоев на уровне файловой структуры проекта и обеспечения контролируемого взаимодействия между слоями.

Этот путеводитель придерживается следующей структуры слоев:

- **слой сервисов** обеспечивает обмен данными между слоем логики и внешними источниками данных.

> Под внешними источниками данных подразумеваются не только удаленные сервера, но и API среды выполнения (вроде Local Storage API, Geolocation API, а также методы и свойства window-объекта, такие как setTimeot).

- **слой логики** отвечает за изменение состояния приложения в ответ на события, приходящие из остальных слоев. 

- **cлой представления** отвечает за выведение локальных состояний, за интерпретацию пользовательских действий в виде понятных слою логики событий.

## Слой представления

Главным строительным блоком слоя представления является React-модуль.

*React-модуль* представляет собой объект, экспортирующий наружу *React-компонент* и опциональный *UNION-тип* генерируемых этим компонентом событий, если такие имеются.

```ts

import { MyComponent, MyComponentEvent } from './MyComponent';

```

Компонент может быть использован в других компонентах, как это обычно в React-приложениях и происходит.

Типы событий всех используемых компонентов будут объеденены в один UNION-тип для последующей типизации редюсера глобального состояния:

```ts

import { MyComponentEvent } from './MyComponent';
import { MyOtherComponentEvent } from './MyOtherComponent';

export type ViewEvent = MyComponentEvent | MyOtherComponentEvent;

```

## Предметные области

Предметная область описывает структуру и жизненный цикл сущностей, взаимодействующих друг с другом в рамках какого-то наблюдаемого процесса.

### Проблеманая область

Проблемная предметная область описывает структуру и жизненных цикл сущностей, взамодействие которых обеспечивается и регулируется приложением. Одна и та же проблемная область может использоваться несколькими приложениями, разрабатываемыми в рамках одного и того же проекта. Процесс взаимодействия сущностей проблемной области может происходить без участия приложения.

Примеры таких сущностей: пользователь, задача, документ.

### Утилитарная область

Утилитарная предметная область описывает структуру и жизненных цикл сущностей, помогающих приложению обеспечивать и регулировать взамодействие сущностей проблемной области. Одна и та же утилитарная область может использоваться разными приложениями, разрабатываемыми в рамках абсолютно разных проектов.

Примеры таких сущностей: коллекция, список, форма.

### Прикладная область

Прикладная предметная область использует утилитарную и проблемную области для описания структуры и жизненного цикла конкретного приложения. Конкретная прикладная область может использоваться одним конкретным приложением. Сущности прикладной области могут существовать только в контексте разрабатываемого приложения.

Примеры таких сущностей: локлаьный кэш задач, форма регистрации.