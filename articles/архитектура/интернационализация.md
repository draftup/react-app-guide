# Интернационализация React-приложения

Судя по развернутому комментарию на сайте W3C интернационализация веб-приложения представляет собой совокупность архитектурных решений, упрощающих дальнейшую локализацию итогового продукта. Другими словами, интернационализация (i18n) является частью процесса разработки приложения, в то время как локализация уже относится к наполнению сайта контентом, соответствующим определенному языковому региону.

Примерами интернационализации являются: создание формы выбора языка интерфейса, работа с определенными браузерными API, проектирование интерфейса с учетом  rtl-языков.

Примерами локализации являются: перевод интерфейса на новый язык, перевод текста изображений, фильтрация контента для пользователей из определенного региона.

В этой статье я поделюсь опытом проектирования веб-приложения на React с учетом перевода на другие языки. Способ этот  не требует использования сторонних библиотек, полагается на стабильные React API и возможности современного JS.

## Контекст

Начнем с создания React-контекста, который будет использоваться для пробрасывания состояния локализации и доступа к нему изнутри компонентов:

```js

export const IntlContext = React.createContext(initialIntl);

```

Провайдер контекста необходимо расположить как можно выше в иерархии компонентов, чтобы гарантировать доступ к состоянию локализации максимально возможному количеству компонентов:

```jsx
const Root = () => {
  return(
    <IntlContext.Provider>
      <ViewComponent>
    </IntlContext.Provider>
  )
}
```

Теперь создадим компонент, который будет использовать словарь локализации. Для наглядности это будет компонент с одной единственной кнопкой:

```jsx
const Button = () => {
  const { buttonText } = React.useContext(IntlContext);

  return(
    <button>
      {buttonText}
    </button>
  )
}
```

Обратите внимание, что мы до сих пор не определились, что эта кнопка будет делать. При этом имя в словаре уже обозначено как buttonText (а не submit, cancel, send). Такой подход к наимеменованию позволяет не привязывать имена значений к их содержимому ("Отправить", "Отменить", "Подтвердить") и если появится необходимость заменить текст кнопки, например, в английской локализации ("Submit" на "Confirm") вам не придется трогать ключ в объекте словаря, чтобы он продолжало соответствовать содержимому.

```js

// Вариант, когда между полями и значениями словаря существует содержательная связь, которую нужно поддерживать.

// Было:

const intlEn = {
  submitButton: 'submit'
}
const intlRu = {
  submitButton: 'отправить'
}

// Стало:

const intlEn = {
  confirmButton: 'confirm' // пришлось изменить и поле и значение
}
const intlRu = {
  confirmButton: 'отправить' // пришлось изменить поле
}

```

```js

// Вариант, когда между полями и значениями словаря нет содержательной связи.

// Было:

const intlEn = {
  buttonText: 'submit'
}
const intlRu = {
  buttonText: 'отправить'
}

// Стало:

const intlEn = {
  buttonText: 'confirm' // пришлось изменить только значение
}
const intlRu = {
  buttonText: 'отправить'
}

```

Но откуда берется сам словарь? Для начала  будем его импортировать напрямую из отдельного файла. У меня эти файлы обычно лежат в папке src/i18n и называются по языковому коду:

```js

// src/i18n/ru.js

export const intlRu = {
  buttonText: 'отправить'
}

```

Сам словарь представляет собой js-объект, а файл, соответственно - полноценный js-модуль. Почему так, а не json? Чтобы можно было хранить в словаре утилитарные функции:

```js

// src/i18n/ru.js

export const intlRu = {
  buttonText: 'отправить',
  hintText(firstName) {
    return `Добро пожаловать, ${firstName}!`
  }
}

```

Структура словарей синхронизируется при помощи статической типизации:

```js

export type IntlDictionary = {
    buttonText: string;
    hintText(firstName: string): string
}

```

```js

// src/i18n/ru.js

export const intlRu: IntlDictionary = {
  buttonText: 'отправить',
  hintText(firstName) {
    return `Добро пожаловать, ${firstName}!`
  }
}

```

```js

// src/i18n/en.js

export const intlEn: IntlDictionary = {
  buttonText: 'confirm',
  hintText(firstName) {
    return `Wellcome, ${firstName}!`
  }
}

```

Обращение к словарю происходит напрямую из компонента с локализуемым контентом при помощи кастомного хука. Я предпочитаю для каждого компонента создавать свои небольшие микрословари. Это обеспечивает гибкость локализации, которую легко ощутить при долгосрочной поддержке проекта.

```js

export type FormIntl = {
  inputPlaceholderText: string;
  submitButtonText: string;
}

```

```jsx

const Form = () => {
  const { form: dict } = React.useContext(IntlContext);

  return(
    <form>
      <input placeholder={dict.inputPlaceholderText} />
      <button>
        {dict.submitButtonText}
      </button>
    </form>
  )
}

```

------ НАБРОСЫ ------

Необходимо создать сервис, при помощи которого можно будет загрузить список языковых кодов от всех доступных словарей. Этот список потом можно будет использовать для предоставления пользователю возможность поменять локализацию при помощи выпадающего меню или какого-нибудь другого UI-элемента.

Необходимо создать сервис, при помощи которого можно будет загрузить словарь интернационализации по языковому коду. Этот сервис можно будет вызывать в момент, когда пользователь поменял язык приложения при помощи UI, а также в момент первой загрузки приложения, когда был автоматически определен предпочитаемый пользователем язык.

Необходимо подготовить все React-компоненты к работе с контекстом i18n. У каждого компонента будет существовать свой собственный микрословарь. Не стоит пытаться создавать словарь, отдельные строки которого могут использоваться в разных компонентах. Такой подход плохо масштабируется. Тем более не стоит пытаться вести словарь, ключи которого содержат семантическую связь с соответствующим ключу значением.

Нужно подготовить хранилище, в котором будут храниться список доступных языковых кодов а также загруженные словари. Если приложение уже имеет хранилище глобального состояния, то имеет смысл хранить эту информацию там.

Нужно создать хук, при помощи которого можно будет обращаться к актуальному i18n словарю. Сам хук, в свою очередь, будет обращаться к глобальному состоянию через соответствующий React Context.

Словарь интернационализации описывается в виде js-модуля. По одному модулю на локаль. Структура словарей синхронизируется при помощи статической типизации. Словарь может содержать не только строки, но и функции-конструкторы. Словари загружаются при помощи динамического импорта.