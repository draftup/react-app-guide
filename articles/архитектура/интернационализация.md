# Интернационализация React-приложения

В этой статье описан способ проектирования веб-приложения на React с учетом перевода на другие языки. Способ этот не требует использования сторонних библиотек, полагается на стабильные React API и возможности современного JS.

## Контекст

Начнем с создания React-контекста, который будет использоваться для пробрасывания словаря локализации и доступа к нему изнутри компонентов:

```js

export const dictionaryRu = {
  form: {
    buttonText: 'отправить',
  }
}

export const DictionaryContext = React.createContext(dictionaryRu);

```

Провайдер контекста необходимо расположить как можно выше в иерархии компонентов, чтобы гарантировать доступ к состоянию локализации всем заинтересованным компонентам:

```jsx

const Root = () => {
  return(
    <DictionaryContext.Provider>
      <ViewComponent>
    </DictionaryContext.Provider>
  )
}

```

## Подключение словаря в компонент

Теперь создадим компонент который будет использовать словарь локализации:

```jsx

const Form = () => {
  const { form } = React.useContext(DictionaryContext);

  return(
    <form>
      <button type="submit">
        {form.buttonText}
      </button>
    </form>
  )
}

```

## Группировка по микрословарям

Обратите внимание на то, что значения локализации в словаре сгруппированы в объект `form`. Это значит, что для каждого компонента существует собственный микрословарь. Такой подход позволяет избежать неконтролируемого разрастания словаря.

```js

export const dictionaryRu = {
  form: {
    buttonText: 'отправить',
  }
}

```

## Наименование полей словаря

Обратите внимание на то, что локализованный текст кнопки хранится под ключем `buttonText`. Название ключа семантически указывает на элемент интерфейса, к которому относится, и не привязывается к содержимому ("Отправить", "Подтвердить", "Ок"). Если появится необходимость заменить текст кнопки (например, в английской локализации заменить "Submit" на "Confirm") не нужно будет трогать ключ значения ни в одном из словарей.

```js

// Вариант, когда между ключами и значениями словаря существует семантическая связь, которую нужно поддерживать.

// Было:

const dictionaryEn = {
  submitButton: 'submit'
}
const dictionaryRu = {
  submitButton: 'отправить'
}

// Стало:

const dictionaryEn = {
  confirmButton: 'confirm' // пришлось изменить и поле и значение
}
const dictionaryRu = {
  confirmButton: 'отправить' // пришлось изменить поле
}

```

```js

// Вариант, когда между полями и значениями словаря нет семантической связи.

// Было:

const dictionaryEn = {
  buttonText: 'submit'
}
const dictionaryRu = {
  buttonText: 'отправить'
}

// Стало:

const dictionaryEn = {
  buttonText: 'confirm' // пришлось изменить только значение
}
const dictionaryRu = {
  buttonText: 'отправить'
}

```

## Использование функций-композиторов

Структурно словарь представляет собой обычный объект, а файл, соответственно, полноценный js-модуль. Это позволяет хранить в словаре функции абстрагирующие логику композиции динамических значений:

```js

export const dictionaryRu = {
  form: {
    buttonText: 'отправить',
    hintText(firstName) {
      return `Добро пожаловать, ${firstName}!`
    }
  }
}

```

## Синхронизация нескольких словарей

При наличии нескольких словарей появляется необходимость в синхронизации их структуры и значений. Здесь поможет статическая типизация.

```ts

export type Dictionary = {
  form: {
    buttonText: string;
    hintText(firstName: string): string;
  };
}

```

```ts

export const dictionaryRu: Dictionary = {
  form: {
    buttonText: 'отправить',
    hintText(firstName) {
      return `Добро пожаловать, ${firstName}!`
    }
  }
}

```

```ts

export const dictionaryEn: Dictionary = {
  form: {
    buttonText: 'confirm',
    hintText(firstName) {
      return `Greetings, ${firstName}!`
    }
  }
}

```

## Динамическая подгрузка словарей

При наличии большого количества словарей появляется необходимость в их ленивой подгрузке, так как большинство пользователей будет использовать не больше одного-двух словарей. Добиться этого легко при помощи динамических импортов:

```js

import('dictionaries/ru').then((dictionaryRu) => {
  // Словарь загружен, можно сохранить его в локальное состояние.
})

```

Таким образом мы выносим словари из основого кода приложения, уменьшая тем самым его размер и, соответственно, сокращая время начальной загрузки.

Чтобы применить такое решение мы предлагаем организовать хранение актулального словая в локлаьном состоянии внутри специального компонента-провайдере:

```tsx

import { dictionaryEn } from 'dictionaries/en';

type Props = {
  language: string;
}

// В качестве начального состояния имеет смысл использовать словарь
// для языка, носители которого чаще встречаются среди ваших пользователей.
const initialDictionary = dictionaryEn;

const IntlProvider = (props) => {
  const { children, language } = props;

  const [dictionary, setDictionary] = React.useState<Dictionary>(initialDictionary);

  React.useEffect(() => {
    intlService
      .getDictionary(language)
      .then(setDictionary)
  },[language])

  return(
    <DictionaryContext.Provider value={dictionary}>
      {children}
    </DictionaryContext.Provider>
  )
}

```

Компонент принимает на вход код языка, для которого нужно загрузить словарь, после чего этот код передаётся в соответствующий сервис. Ниже представлена одна из возможных реализаций такого сервиса.

```tsx

type IntlService = {
  getAvailableLanguages(): Promise<string[]>;
  getDictionary(language: string): Promise<Dictionary>;
}

// Асинхронные функции, отвечающие за загрузку словарей,
// удобно хранить в Map-объекте, где ключом к конкретной
// функции-загрузчику выступает языковой код.

const dictionaryLoaders = new Map();

dictionaryLoaders.set('en', () => import('dictionaries/en'))
dictionaryLoaders.set('ru', () => import('dictionaries/ru'))
dictionaryLoaders.set('es', () => import('dictionaries/es'))

export const intlService: IntlService = {
  async getAvailableLanguages() {
    // Этот метод позволяет получить список языковых кодов,
    // для которых доступны словари.
    // Полученный список можно отобразить в виде выпадающего списка,
    // который позволит пользователю переключаться между языками.
    return Array.from(map.keys())
  },
  async getDictionary(language) {
    const loadDictionary = dictionaryLoaders.get(language)

    if (loadDictionary) {
      return loadDictionary()
    }

    throw new IntlError(`Failed to load dictionary for language "${language}"`);
  }
}


```

Разместить этот компонент нужно как можно выше в дереве компонентов, заменив им `DictionaryContext.Provider`:

```jsx

const Root = () => {
  return(
    <DictionaryProvider language={currentLanguage}>
      <ViewComponent>
    </DictionaryProvider>
  )
}

```


------ НАБРОСЫ ------

Необходимо создать сервис, при помощи которого можно будет загрузить список языковых кодов от всех доступных словарей. Этот список потом можно будет использовать для предоставления пользователю возможность поменять локализацию при помощи выпадающего меню или какого-нибудь другого UI-элемента.

Необходимо создать сервис, при помощи которого можно будет загрузить словарь интернационализации по языковому коду. Этот сервис можно будет вызывать в момент, когда пользователь поменял язык приложения при помощи UI, а также в момент первой загрузки приложения, когда был автоматически определен предпочитаемый пользователем язык.

Необходимо подготовить все React-компоненты к работе с контекстом i18n. У каждого компонента будет существовать свой собственный микрословарь. Не стоит пытаться создавать словарь, отдельные строки которого могут использоваться в разных компонентах. Такой подход плохо масштабируется. Тем более не стоит пытаться вести словарь, ключи которого содержат семантическую связь с соответствующим ключу значением.

Нужно подготовить хранилище, в котором будут храниться список доступных языковых кодов а также загруженные словари. Если приложение уже имеет хранилище глобального состояния, то имеет смысл хранить эту информацию там.

Нужно создать хук, при помощи которого можно будет обращаться к актуальному i18n словарю. Сам хук, в свою очередь, будет обращаться к глобальному состоянию через соответствующий React Context.

Словарь интернационализации описывается в виде js-модуля. По одному модулю на локаль. Структура словарей синхронизируется при помощи статической типизации. Словарь может содержать не только строки, но и функции-конструкторы. Словари загружаются при помощи динамического импорта.