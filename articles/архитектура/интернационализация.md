# Интернационализация React-приложения

В этой статье описан способ проектирования веб-приложения на React с учетом перевода на другие языки. Способ этот не требует использования сторонних библиотек, полагается на стабильные React API и возможности современного JS.

## Контекст

Начнем с создания React-контекста, который будет использоваться для пробрасывания словаря локализации и доступа к нему изнутри компонентов:

```js

export const dictionaryRu = {
  form: {
    buttonText: 'отправить',
  }
}

export const DictionaryContext = React.createContext(dictionaryRu);

```

Провайдер контекста необходимо расположить как можно выше в иерархии компонентов, чтобы гарантировать доступ к состоянию локализации всем заинтересованным компонентам:

```jsx

const Root = () => {
  return(
    <DictionaryContext.Provider>
      <ViewComponent>
    </DictionaryContext.Provider>
  )
}

```

## Подключение словаря в компонент

Теперь создадим компонент который будет использовать словарь локализации:

```jsx

const Form = () => {
  const { form } = React.useContext(DictionaryContext);

  return(
    <form>
      <button type="submit">
        {form.buttonText}
      </button>
    </form>
  )
}

```

## Группировка по микрословарям

Обратите внимание на то, что значения локализации в словаре сгруппированы в объект `form`. Это значит, что для каждого компонента существует собственный микрословарь. Такой подход позволяет избежать неконтролируемого разрастания словаря.

```js

export const dictionaryRu = {
  form: {
    buttonText: 'отправить',
  }
}

```

## Наименование полей словаря

Обратите внимание на то, что локализованный текст кнопки хранится под ключем `buttonText`. Название ключа семантически указывает на элемент интерфейса, к которому относится, и не привязывается к содержимому ("Отправить", "Подтвердить", "Ок"). Если появится необходимость заменить текст кнопки (например, в английской локализации заменить "Submit" на "Confirm") не нужно будет трогать ключ значения ни в одном из словарей.

```js

// Вариант, когда между ключами и значениями словаря существует семантическая связь, которую нужно поддерживать.

// Было:

const dictionaryEn = {
  submitButton: 'submit'
}
const dictionaryRu = {
  submitButton: 'отправить'
}

// Стало:

const dictionaryEn = {
  confirmButton: 'confirm' // пришлось изменить и поле и значение
}
const dictionaryRu = {
  confirmButton: 'отправить' // пришлось изменить поле
}

```

```js

// Вариант, когда между полями и значениями словаря нет семантической связи.

// Было:

const dictionaryEn = {
  buttonText: 'submit'
}
const dictionaryRu = {
  buttonText: 'отправить'
}

// Стало:

const dictionaryEn = {
  buttonText: 'confirm' // пришлось изменить только значение
}
const dictionaryRu = {
  buttonText: 'отправить'
}

```

## Использование функций-композиторов

Структурно словарь представляет собой обычный объект, а файл, соответственно, полноценный js-модуль. Это позволяет хранить в словаре функции абстрагирующие логику композиции динамических значений:

```js

export const dictionaryRu = {
  form: {
    buttonText: 'отправить',
    hintText(firstName) {
      return `Добро пожаловать, ${firstName}!`
    }
  }
}

```

## Синхронизация нескольких словарей

При наличии нескольких словарей появляется необходимость в синхронизации их структуры и значений. Здесь поможет статическая типизация.

```js

export type Dictionary = {
  form: {
    buttonText: string;
    hintText(firstName: string): string;
  };
}

```

```js

export const dictionaryRu: Dictionary = {
  form: {
    buttonText: 'отправить',
    hintText(firstName) {
      return `Добро пожаловать, ${firstName}!`
    }
  }
}

```

```js

export const dictionaryEn: Dictionary = {
  form: {
    buttonText: 'confirm',
    hintText(firstName) {
      return `Greetings, ${firstName}!`
    }
  }
}

```

## Динамическая подгрузка словарей

При наличии большого количества словарей появляется необходимость в их ленивой подгрузке, так как большинство пользователей будет использовать не больше одного-двух словарей. Добиться этого легко при помощи динамических импортов:

```js

import('dictionaries/ru').then((dictionaryRu) => {
  // Словарь загружен, можно сохранить его в локальное состояние.
})

```

Таким образом мы выносим словари из основого кода приложения, уменьшая тем самым его размер и, соответственно, сокращая время начальной загрузки.

Чтобы применить такое решение мы предлагаем организовать хранение актуального словая в локлаьном состоянии внутри специального компонента-провайдера:

```jsx

import { dictionaryEn } from 'dictionaries/en';

type Props = {
  language: string;
}

// В качестве начального состояния имеет смысл использовать словарь
// для языка, носители которого чаще встречаются среди ваших пользователей.
// Например, если продукт ориентирован на международный рынок, этим языком
// может быть английский.
const initialDictionary = dictionaryEn;

const DictionaryProvider = (props) => {
  const { children, language } = props;

  const [dictionary, setDictionary] = React.useState<Dictionary>(initialDictionary);

  React.useEffect(() => {
    intlService
      .getDictionary(language)
      .then(setDictionary)
  },[language])

  return(
    <DictionaryContext.Provider value={dictionary}>
      {children}
    </DictionaryContext.Provider>
  )
}

```

Компонент принимает на вход код языка, для которого нужно загрузить словарь, после чего этот код передаётся в соответствующий сервис. Ниже представлена одна из возможных реализаций такого сервиса.

```jsx

type IntlService = {
  getAvailableLanguages(): Promise<string[]>;
  getDictionary(language: string): Promise<Dictionary>;
}

// Асинхронные функции, отвечающие за загрузку словарей,
// удобно хранить в Map-объекте, где ключом к конкретной
// функции-загрузчику выступает языковой код.

const dictionaryLoaders = new Map();

dictionaryLoaders.set('en', () => import('dictionaries/en'))
dictionaryLoaders.set('ru', () => import('dictionaries/ru'))
dictionaryLoaders.set('es', () => import('dictionaries/es'))

export const intlService: IntlService = {
  async getAvailableLanguages() {
    // Этот метод позволяет получить список языковых кодов,
    // для которых доступны словари.
    // Полученный массив можно отобразить в виде выпадающего списка,
    // который позволит пользователю переключаться между языками.
    return Array.from(map.keys())
  },
  async getDictionary(language) {
    const loadDictionary = dictionaryLoaders.get(language)

    if (loadDictionary) {
      return loadDictionary()
    }

    throw new IntlError(`Failed to load dictionary for language "${language}"`);
  }
}

```

Новый компонент нужно разместить как можно выше в иерархии, заменив им `DictionaryContext.Provider`:

```jsx

const Root = () => {
  // Вариант хранения значения выбранного языка
  // оставляем на ваше усмотрение.
  const { currentLanguage } = useAppState();

  return(
    <DictionaryProvider language={currentLanguage}>
      <ViewComponent>
    </DictionaryProvider>
  )
}

```

TODO: разобраться что делать с локалями браузера, как их сочетать со списком доступных словарей.
