# Интернационализация React-приложения

В этой статье описан способ проектирования веб-приложения на React с учетом перевода на другие языки. Способ этот не требует использования сторонних библиотек, полагается на стабильные React API и возможности современного JS.

## Контекст

Начнем с создания React-контекста, который будет использоваться для пробрасывания словаря локализации и доступа к нему изнутри компонентов:

```js

export const DictionaryContext = React.createContext(dictionaryRu);

```

Провайдер контекста необходимо расположить как можно выше в иерархии компонентов, чтобы гарантировать доступ к состоянию локализации всем заинтересованным компонентам:

```jsx

const Root = () => {
  return(
    <IntlContext.Provider>
      <ViewComponent>
    </IntlContext.Provider>
  )
}

```

Теперь создадим компонент, который будет использовать словарь локализации. Допустим, это будет кнопка отправки формы:

```jsx

const Form = () => {
  const { form } = React.useContext(DictionaryContext);

  return(
    <button type="submit">
      {form.buttonText}
    </button>
  )
}

```

Обратите внимание на то, что значения локализации в словаре сгруппированы в объект `form`. Это значит, что для каждого компонента существует собственный микрословарь. Не пытайтесь проектировать словарь таким образом, чтобы отдельные его поля можно было использовать в разных компонентах. Такой словарь будет сложно поддерживать.

Кроме того обратите внимание на то, что локализованный текст кнопки хранится под ключем `buttonText` и никак не привязыван к содержимому ("Отправить", "Подтвердить", "Ок"). Если появится необходимость заменить текст кнопки (например, в английской локализации заменить "Submit" на "Confirm") не нужно будет трогать ключ значения ни в одном из словарей.

```js

// Вариант, когда между ключами и значениями словаря существует семантическая связь, которую нужно поддерживать.

// Было:

const dictionaryEn = {
  submitButton: 'submit'
}
const dictionaryRu = {
  submitButton: 'отправить'
}

// Стало:

const dictionaryEn = {
  confirmButton: 'confirm' // пришлось изменить и поле и значение
}
const dictionaryRu = {
  confirmButton: 'отправить' // пришлось изменить поле
}

```

```js

// Вариант, когда между полями и значениями словаря нет семантической связи.

// Было:

const dictionaryEn = {
  buttonText: 'submit'
}
const dictionaryRu = {
  buttonText: 'отправить'
}

// Стало:

const dictionaryEn = {
  buttonText: 'confirm' // пришлось изменить только значение
}
const dictionaryRu = {
  buttonText: 'отправить'
}

```

Структурно словарь представляет собой обычный объект, а файл, соответственно, полноценный js-модуль. Почему так, а не json? Чтобы можно было хранить в словаре функции, абстрагирующие логику композиции динамических значений:

```js

export const dictionaryRu = {
  form: {
    buttonText: 'отправить',
    hintText(firstName) {
      return `Добро пожаловать, ${firstName}!`
    }
  }
}

```

При наличии нескольких словарей появляется необходимость в синхронизации их структуры и значений. Здесь поможет статическая типизация.

```js

export type Dictionary = {
  form: {
    buttonText: string;
    hintText(firstName: string): string;
  };
}

```

```js

export const dictionaryRu: Dictionary = {
  form: {
    buttonText: 'отправить',
    hintText(firstName) {
      return `Добро пожаловать, ${firstName}!`
    }
  }
}

```

```js

export const dictionaryEn: Dictionary = {
  form: {
    buttonText: 'confirm',
    hintText(firstName) {
      return `Greetings, ${firstName}!`
    }
  }
}

```

В таком виде объекты словарей будут разрастаться по мере увеличения количества локализуемых компонентов в проекте. Вместе с размером словарей будет усложняться их поддержка.

Чтобы этого избежать достаточно микрословари компонентов хранить отдельно и импортировать их в файл словаря:

```js

export type FormDictionary = {
  buttonText: string;
  hintText(firstName: string): string;
}

```

```js

export const formDictionaryRu: FormDictionary = {
  buttonText: 'отправить',
  hintText(firstName) {
    return `Добро пожаловать, ${firstName}!`
  }
}

```

```js

export const formDictionaryEn: FormDictionary = {
  buttonText: 'confirm',
  hintText(firstName) {
    return `Greetings, ${firstName}!`
  }
}

```

```js

export type Dictionary = {
  form: FormDictionary;
}

```

```js

export const dictionaryRu: Dictionary = {
  form: formDictionaryRu,
}

```

```js

export const dictionaryEn: Dictionary = {
  form: formDictionaryEn,
}

```


------ НАБРОСЫ ------

Необходимо создать сервис, при помощи которого можно будет загрузить список языковых кодов от всех доступных словарей. Этот список потом можно будет использовать для предоставления пользователю возможность поменять локализацию при помощи выпадающего меню или какого-нибудь другого UI-элемента.

Необходимо создать сервис, при помощи которого можно будет загрузить словарь интернационализации по языковому коду. Этот сервис можно будет вызывать в момент, когда пользователь поменял язык приложения при помощи UI, а также в момент первой загрузки приложения, когда был автоматически определен предпочитаемый пользователем язык.

Необходимо подготовить все React-компоненты к работе с контекстом i18n. У каждого компонента будет существовать свой собственный микрословарь. Не стоит пытаться создавать словарь, отдельные строки которого могут использоваться в разных компонентах. Такой подход плохо масштабируется. Тем более не стоит пытаться вести словарь, ключи которого содержат семантическую связь с соответствующим ключу значением.

Нужно подготовить хранилище, в котором будут храниться список доступных языковых кодов а также загруженные словари. Если приложение уже имеет хранилище глобального состояния, то имеет смысл хранить эту информацию там.

Нужно создать хук, при помощи которого можно будет обращаться к актуальному i18n словарю. Сам хук, в свою очередь, будет обращаться к глобальному состоянию через соответствующий React Context.

Словарь интернационализации описывается в виде js-модуля. По одному модулю на локаль. Структура словарей синхронизируется при помощи статической типизации. Словарь может содержать не только строки, но и функции-конструкторы. Словари загружаются при помощи динамического импорта.