# Интернационализация React-приложения

В этой статье описан способ проектирования веб-приложения на React с учетом перевода на другие языки. Способ этот не требует использования сторонних библиотек, полагается на стабильные React API и возможности современного JS.

## Контекст

Начнем с создания React-контекста, который будет использоваться для пробрасывания словаря локализации и доступа к нему изнутри компонентов:

```js

export const dictionaryRu = {
  form: {
    buttonText: 'отправить',
  }
}

export const DictionaryContext = React.createContext(dictionaryRu);

```

Провайдер контекста необходимо расположить как можно выше в иерархии компонентов, чтобы гарантировать доступ к состоянию локализации всем заинтересованным компонентам:

```jsx

const Root = () => {
  return(
    <IntlContext.Provider>
      <ViewComponent>
    </IntlContext.Provider>
  )
}

```

## Подключение словаря в компонент

Теперь создадим компонент который будет использовать словарь локализации:

```jsx

const Form = () => {
  const { form } = React.useContext(DictionaryContext);

  return(
    <form>
      <button type="submit">
        {form.buttonText}
      </button>
    </form>
  )
}

```

## Группировка по микрословарям

Обратите внимание на то, что значения локализации в словаре сгруппированы в объект `form`. Это значит, что для каждого компонента существует собственный микрословарь. Такой подход позволяет избежать неконтролируемого разрастания словаря.

```js

export const dictionaryRu = {
  form: {
    buttonText: 'отправить',
  }
}

```

## Наименование полей словаря

Обратите внимание на то, что локализованный текст кнопки хранится под ключем `buttonText`. Название ключа семантически указывает на элемент интерфейса, к которому относится, и не привязыван к содержимому ("Отправить", "Подтвердить", "Ок"). Если появится необходимость заменить текст кнопки (например, в английской локализации заменить "Submit" на "Confirm") не нужно будет трогать ключ значения ни в одном из словарей.

```js

// Вариант, когда между ключами и значениями словаря существует семантическая связь, которую нужно поддерживать.

// Было:

const dictionaryEn = {
  submitButton: 'submit'
}
const dictionaryRu = {
  submitButton: 'отправить'
}

// Стало:

const dictionaryEn = {
  confirmButton: 'confirm' // пришлось изменить и поле и значение
}
const dictionaryRu = {
  confirmButton: 'отправить' // пришлось изменить поле
}

```

```js

// Вариант, когда между полями и значениями словаря нет семантической связи.

// Было:

const dictionaryEn = {
  buttonText: 'submit'
}
const dictionaryRu = {
  buttonText: 'отправить'
}

// Стало:

const dictionaryEn = {
  buttonText: 'confirm' // пришлось изменить только значение
}
const dictionaryRu = {
  buttonText: 'отправить'
}

```

## Использование функций-композиторов

Структурно словарь представляет собой обычный объект, а файл, соответственно, полноценный js-модуль. Почему так, а не json? Чтобы можно было хранить в словаре функции абстрагирующие логику композиции динамических значений:

```js

export const dictionaryRu = {
  form: {
    buttonText: 'отправить',
    hintText(firstName) {
      return `Добро пожаловать, ${firstName}!`
    }
  }
}

```

## Синхронизация нескольких словарей

При наличии нескольких словарей появляется необходимость в синхронизации их структуры и значений. Здесь поможет статическая типизация.

```ts

export type Dictionary = {
  form: {
    buttonText: string;
    hintText(firstName: string): string;
  };
}

```

```ts

export const dictionaryRu: Dictionary = {
  form: {
    buttonText: 'отправить',
    hintText(firstName) {
      return `Добро пожаловать, ${firstName}!`
    }
  }
}

```

```ts

export const dictionaryEn: Dictionary = {
  form: {
    buttonText: 'confirm',
    hintText(firstName) {
      return `Greetings, ${firstName}!`
    }
  }
}

```

## Динамическая подгрузка словарей

При наличии большого количества словарей появляется необходимость в их ленивой подгрузке. Вызвано это тем, что большинство клиентских приложений будет использовать не больше одного-двух словарей. Добиться этого легко при помощи динамических импортов:

```js

import('dictionaries/ru').then((dictionaryRu) => {
  // Словарь загружен, можно сохранить его в локальное состояние.
})

```

Таким образом мы выносим словари из основого кода приложения, уменьшая тем самым его размер и, соответственно, сокращая время загрузки.

Чтобы применить такое решение в приложении придётся организовать хранение словарей в специальном компоненте-провайдере:

```tsx

type Intl = {
  availableLanguages: string[];
  currentLanguage: string;
  dictionary: Dictionary;
}

const IntlProvider = (props) => {
  const { children } = props;

  const [intl, setIntl] = React.useState<Intl>();

  return(
    <IntlContext.Provider value={}>
      {children}
    </IntlContext.Provider>
  )
}

```



------ НАБРОСЫ ------

Необходимо создать сервис, при помощи которого можно будет загрузить список языковых кодов от всех доступных словарей. Этот список потом можно будет использовать для предоставления пользователю возможность поменять локализацию при помощи выпадающего меню или какого-нибудь другого UI-элемента.

Необходимо создать сервис, при помощи которого можно будет загрузить словарь интернационализации по языковому коду. Этот сервис можно будет вызывать в момент, когда пользователь поменял язык приложения при помощи UI, а также в момент первой загрузки приложения, когда был автоматически определен предпочитаемый пользователем язык.

Необходимо подготовить все React-компоненты к работе с контекстом i18n. У каждого компонента будет существовать свой собственный микрословарь. Не стоит пытаться создавать словарь, отдельные строки которого могут использоваться в разных компонентах. Такой подход плохо масштабируется. Тем более не стоит пытаться вести словарь, ключи которого содержат семантическую связь с соответствующим ключу значением.

Нужно подготовить хранилище, в котором будут храниться список доступных языковых кодов а также загруженные словари. Если приложение уже имеет хранилище глобального состояния, то имеет смысл хранить эту информацию там.

Нужно создать хук, при помощи которого можно будет обращаться к актуальному i18n словарю. Сам хук, в свою очередь, будет обращаться к глобальному состоянию через соответствующий React Context.

Словарь интернационализации описывается в виде js-модуля. По одному модулю на локаль. Структура словарей синхронизируется при помощи статической типизации. Словарь может содержать не только строки, но и функции-конструкторы. Словари загружаются при помощи динамического импорта.